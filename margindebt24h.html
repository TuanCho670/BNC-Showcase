<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <title>Binance Margin Debt Calculator</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      padding: 20px;
    }
    .status {
      margin-top: 20px;
      padding: 10px;
      background: #f5f5f5;
      border-radius: 4px;
    }
    .data-table {
      width: 100%;
      margin-top: 20px;
      border-collapse: collapse;
    }
    .data-table th, .data-table td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
    }
    .data-table th {
      background-color: #f3f3f3;
      font-weight: bold;
    }
    #symbolList {
      margin-top: 20px;
      padding: 10px;
      background: #f8f9fa;
      border: 1px solid #ddd;
    }
  </style>
</head>
<body>
  <h2>Binance Margin Debt Calculator</h2>
  <div id="status" class="status">Starting...</div>
  
  <!-- Hiển thị danh sách symbols -->
  <div id="symbolList"></div>

  <!-- Bảng dữ liệu margin debt -->
  <table class="data-table">
    <thead>
      <tr>
        <th>Symbol</th>
        <th>Current Time</th>
        <th>Current %</th>
        <th>Highest % (Time)</th>
      </tr>
    </thead>
    <tbody id="dataBody"></tbody>
  </table>

  <script>
    const BATCH_SIZE = 50;        // Số lượng symbols xử lý mỗi batch
    const BATCH_DELAY = 120000;   // Delay 2 phút (120000ms) giữa các batch
    
    window.onload = async function() {
      try {
        // 1. Lấy và hiển thị danh sách symbols
        const symbols = await fetchSymbols();
        displaySymbols(symbols);
        
        // 2. Xử lý theo từng batch
        const batches = chunkArray(symbols, BATCH_SIZE);
        for(let i = 0; i < batches.length; i++) {
          document.getElementById('status').innerHTML = 
            "Processing batch " + (i + 1) + "/" + batches.length + "...";
          
          // Xử lý batch hiện tại
          await processBatch(batches[i]);
          
          // Nếu còn batch tiếp theo thì delay
          if (i < batches.length - 1) {
            document.getElementById('status').innerHTML = 
              "Waiting 2 minutes before next batch...";
            await new Promise(resolve => setTimeout(resolve, BATCH_DELAY));
          }
        }
        
        document.getElementById('status').innerHTML = 'Complete! All batches processed.';
        
      } catch (error) {
        document.getElementById('status').innerHTML = 'Error: ' + error.message;
        console.error(error);
      }
    }

    // Lấy danh sách symbols
    async function fetchSymbols() {
      document.getElementById('status').innerHTML = 'Fetching symbols...';
      
      const response = await fetch('https://api.binance.com/api/v3/exchangeInfo');
      const data = await response.json();
      
      let symbols = data.symbols
        .filter(s => s.quoteAsset === 'USDT' && s.status === 'TRADING')
        .map(s => s.baseAsset);
      
      // Đảm bảo BTC lên đầu
      symbols = ['BTC', ...symbols.filter(s => s !== 'BTC')];
      
      return symbols;
    }

    // Hiển thị danh sách symbols
    function displaySymbols(symbols) {
      const symbolList = document.getElementById('symbolList');
      symbolList.innerHTML = 'Found ' + symbols.length + ' symbols:<br>' +
        symbols.map((s, i) => (i + 1) + '. ' + s).join(', ');
    }

    // Chia array thành các batch nhỏ hơn
    function chunkArray(array, size) {
      const chunks = [];
      for (let i = 0; i < array.length; i += size) {
        chunks.push(array.slice(i, i + size));
      }
      return chunks;
    }

    // Xử lý một batch symbols
    async function processBatch(symbols) {
      for(let symbol of symbols) {
        try {
          const marginUrl = "https://www.binance.com/bapi/margin/v1/public/margin/marketStats/marginDebt?asset=" + 
            symbol + "&period=1&limit=24";
          const marginResponse = await fetch(marginUrl);
          const marginData = await marginResponse.json();

          if (marginData.data && marginData.data.length > 0) {
            const sortedData = marginData.data.sort((a, b) => b.timestamp - a.timestamp);
            const latestData = sortedData[0];
            const highestData = sortedData.reduce((max, current) => 
              current.marginDebtGrowth > max.marginDebtGrowth ? current : max, sortedData[0]
            );

            const result = {
              symbol: symbol + '/USDT',
              currentTime: new Date(latestData.timestamp),
              currentPercentage: (latestData.marginDebtGrowth * 100).toFixed(2),
              highestPercentage: (highestData.marginDebtGrowth * 100).toFixed(2),
              highestTime: new Date(highestData.timestamp)
            };

            addRowToTable(result);

            await new Promise((resolve, reject) => {
              google.script.run
                .withSuccessHandler(resolve)
                .withFailureHandler(reject)
                .updateSymbolData(result);
            });
          }

          await new Promise(resolve => setTimeout(resolve, 1000));
          
        } catch (error) {
          console.error("Error processing " + symbol + ":", error);
        }
      }
    }

    // Thêm dòng vào bảng
    function addRowToTable(data) {
      const tbody = document.getElementById('dataBody');
      const row = document.createElement('tr');
      
      row.innerHTML = 
        "<td>" + data.symbol + "</td>" +
        "<td>" + data.currentTime.toLocaleString() + "</td>" +
        "<td>" + data.currentPercentage + "%</td>" +
        "<td>" + data.highestPercentage + "% (" + data.highestTime.toLocaleString() + ")</td>";
      
      tbody.appendChild(row);
      row.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
  </script>
</body>
</html>
