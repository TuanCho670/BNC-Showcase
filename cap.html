<!DOCTYPE html>
<html>
<head>
    <title>Binance Capital Flow Tracker</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
        }
        input, button {
            padding: 5px 10px;
            margin-bottom: 10px;
            margin-right: 5px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            padding: 8px;
            text-align: left;
            border: 1px solid #ddd;
        }
        th {
            background-color: #f2f2f2;
            font-weight: normal;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .positive { color: rgb(8, 218, 8); }
        .negative { color: rgb(0, 0, 0); }
        .loading { margin: 10px 0; }
        .error { 
            color: red;
            margin: 10px 0;
        }
        .symbol-link {
            text-decoration: none;
            color: inherit;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        .symbol-link:hover {
            background-color: #e6e6e6;
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <input type="text" id="searchInput" placeholder="Search symbols">
            <button onclick="fetchAllData()" id="fetchButton">Fetch Data</button>
            <button onclick="sortTable()" id="sortButton">Sort by Total Flow</button>
            <button onclick="clearCache()" id="clearButton">Clear Cache</button>
        </div>
        <div id="loading" class="loading" style="display: none;">Loading data... <span id="progress"></span></div>
        <div id="error" class="error"></div>
        <div id="stats"></div>
        <table>
            <thead>
                <tr>
                    <th>Symbol</th>
                    <th>Rank</th>
                    <th>Market Cap</th>
                    <th>FDMC</th>
                    <th>Total Flow</th>
                    <th>Day 1</th>
                    <th>Day 2</th>
                    <th>Day 3</th>
                    <th>Day 4</th>
                    <th>Day 5</th>
                    <th>Day 6</th>
                    <th>Day 7</th>
                </tr>
            </thead>
            <tbody id="dataTable"></tbody>
        </table>
    </div>

    <script>
        // Constants
        const API = {
            BASE_URL: 'https://www.binance.com/bapi/earn/v1/public/indicator/capital-flow/volumeTypeNetCapitalIn',
            MARKET_DATA_URL: 'https://www.binance.com/bapi/apex/v1/friendly/apex/marketing/tardingPair/detail',
            EXCHANGE_INFO_URL: 'https://api.binance.com/api/v3/exchangeInfo'
        };

        const CONFIG = {
            BATCH_SIZE: 50,
            BATCH_DELAY: 45000,
            REQUEST_DELAY: 1000,
            CACHE_DURATION: 24 * 60 * 60 * 1000,
            AUTO_REFRESH_INTERVAL: 2 * 60 * 60 * 1000
        };

        const CACHE_KEYS = {
            DATA: 'binance_volume_data',
            TIMESTAMP: 'binance_volume_timestamp'
        };

        // State management
        let state = {
            symbols: [],
            volumeData: [],
            sortDirection: 'desc',
            isProcessing: false,
            autoRefreshTimer: null
        };

        // Utility functions
        const utils = {
            delay: ms => new Promise(resolve => setTimeout(resolve, ms)),
            
            getBaseSymbol: symbol => symbol.split('USDT')[0],

            formatNumber: (num) => {
                if (typeof num !== 'number') return '0';
                const absNum = Math.abs(num);
                let formattedNum;
                
                if (absNum >= 1000000) {
                    formattedNum = (num / 1000000).toFixed(2) + 'M';
                } else if (absNum >= 1000) {
                    formattedNum = (num / 1000).toFixed(2) + 'K';
                } else {
                    formattedNum = num.toFixed(2);
                }
                return formattedNum.replace(/\.?0+([KM])?$/, '$1');
            },
            
            formatMarketCap: (num) => {
                if (typeof num !== 'number' || isNaN(num)) return 'N/A';
                const tiers = [
                    { threshold: 1e12, suffix: 'T' },
                    { threshold: 1e9, suffix: 'B' },
                    { threshold: 1e6, suffix: 'M' },
                    { threshold: 1e3, suffix: 'K' }
                ];
                
                for (const {threshold, suffix} of tiers) {
                    if (num >= threshold) {
                        return `${(num / threshold).toFixed(2)}${suffix}`;
                    }
                }
                return `${num.toFixed(2)}`;
            },
            
            getVolumeClass: value => value >= 0 ? 'positive' : 'negative'
        };

        // Cache management
        const cache = {
            save: (data) => {
                try {
                    localStorage.setItem(CACHE_KEYS.DATA, JSON.stringify(data));
                    localStorage.setItem(CACHE_KEYS.TIMESTAMP, Date.now().toString());
                } catch (error) {
                    console.error('Error saving to cache:', error);
                }
            },

            get: () => {
                try {
                    const timestamp = parseInt(localStorage.getItem(CACHE_KEYS.TIMESTAMP));
                    if (!timestamp || Date.now() - timestamp > CONFIG.CACHE_DURATION) return null;
                    return JSON.parse(localStorage.getItem(CACHE_KEYS.DATA));
                } catch (error) {
                    console.error('Error reading from cache:', error);
                    return null;
                }
            },

            clear: () => {
                try {
                    localStorage.removeItem(CACHE_KEYS.DATA);
                    localStorage.removeItem(CACHE_KEYS.TIMESTAMP);
                    state.volumeData = [];
                    displayData();
                    updateStats();
                    showMessage('Cache cleared successfully!');
                    fetchAllData();
                } catch (error) {
                    showMessage('Error clearing cache: ' + error.message, 'error');
                }
            }
        };

        // API calls
        const api = {
            async fetchWithRetry(url, options, maxRetries = 3) {
                let lastError;
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        const response = await fetch(url, options);
                        if (response.status === 429) {
                            await utils.delay(CONFIG.BATCH_DELAY);
                            continue;
                        }
                        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                        return await response.json();
                    } catch (error) {
                        lastError = error;
                        if (i < maxRetries - 1) await utils.delay(5000 * (i + 1));
                    }
                }
                throw lastError;
            },

            async getExchangeInfo() {
                try {
                    const data = await this.fetchWithRetry(API.EXCHANGE_INFO_URL, {});
                    return data.symbols
                        .filter(s => s.status === 'TRADING' && s.symbol.endsWith('USDT'))
                        .map(s => s.symbol);
                } catch (error) {
                    showMessage('Error fetching exchange info: ' + error.message, 'error');
                    return [];
                }
            },

            async fetchMarketData(symbol) {
                try {
                    const baseSymbol = utils.getBaseSymbol(symbol);
                    const data = await this.fetchWithRetry(`${API.MARKET_DATA_URL}?symbol=${baseSymbol}`);
                    return {
                        rank: data.data?.rk || 'N/A',
                        marketCap: data.data?.mc || 'N/A',
                        fdmc: data.data?.fdmc || 'N/A'
                    };
                } catch (error) {
                    console.error(`Error fetching market data for ${symbol}:`, error);
                    return { rank: 'N/A', marketCap: 'N/A', fdmc: 'N/A' };
                }
            },

            async fetchVolumeData(symbol) {
                try {
                    const params = new URLSearchParams({
                        groupCount: 7,
                        groupSize: 24,
                        period: 'HOUR_1',
                        volumeType: 'BIG',
                        symbol: symbol
                    });
                    const [volumeData, marketData] = await Promise.all([
                        this.fetchWithRetry(`${API.BASE_URL}?${params}`),
                        this.fetchMarketData(symbol)
                    ]);
                    return { volumeData, marketData };
                } catch (error) {
                    console.error(`Error fetching data for ${symbol}:`, error);
                    return null;
                }
            }
        };

        // UI functions
        function showMessage(message, type = 'info') {
            const element = document.getElementById(type === 'error' ? 'error' : 'loading');
            element.textContent = message;
            if (type !== 'loading') {
                setTimeout(() => element.textContent = '', 5000);
            }
        }

        function updateProgress(current, total, currentBatch, totalBatches) {
            showMessage(`Processing ${current}/${total} symbols (Batch ${currentBatch}/${totalBatches})`, 'loading');
        }

        function updateStats() {
            const statsElement = document.getElementById('stats');
            const totalSymbols = state.volumeData.length;
            const positiveFlow = state.volumeData.filter(d => d.totalFlow >= 0).length;
            const negativeFlow = totalSymbols - positiveFlow;
            
            const timestamp = parseInt(localStorage.getItem(CACHE_KEYS.TIMESTAMP));
            const lastUpdate = timestamp ? new Date(timestamp).toLocaleString() : 'N/A';
            const nextUpdate = timestamp ? new Date(timestamp + CONFIG.AUTO_REFRESH_INTERVAL).toLocaleString() : 'N/A';
            
            statsElement.innerHTML = `
                Total Pairs: ${totalSymbols} | 
                Positive Flow: ${positiveFlow} | 
                Negative Flow: ${negativeFlow} |
                Last Updated: ${lastUpdate} |
                Next Update: ${nextUpdate}
            `;
        }

        function displayData() {
            const searchTerm = document.getElementById('searchInput').value.toUpperCase();
            const dataTable = document.getElementById('dataTable');
            dataTable.innerHTML = '';
            
            const filteredData = state.volumeData.filter(data => 
                data.symbol.includes(searchTerm)
            );

            filteredData.forEach(data => {
                const row = document.createElement('tr');
                const flowCells = [...data.flows].reverse().map(flow => 
                    `<td class="${utils.getVolumeClass(flow.netCapitalInflowVolume)}">
                        ${utils.formatNumber(flow.netCapitalInflowVolume)}
                    </td>`
                ).join('');

                row.innerHTML = `
                    <td>
                        <a href="https://www.binance.com/vi/trade/${data.symbol}?type=spot" 
                           target="_blank" 
                           class="symbol-link">
                            ${data.symbol}
                        </a>
                    </td>
                    <td>No.${data.marketData?.rank || 'N/A'}</td>
                    <td>${utils.formatMarketCap(data.marketData?.marketCap)}</td>
                    <td>${utils.formatMarketCap(data.marketData?.fdmc)}</td>
                    <td class="${utils.getVolumeClass(data.totalFlow)}">
                        ${utils.formatNumber(data.totalFlow)}
                    </td>
                    ${flowCells}
                `;
                dataTable.appendChild(row);
            });

            updateStats();
        }

        // Main functions
        async function processBatch(symbols) {
            const batches = [];
            for (let i = 0; i < symbols.length; i += CONFIG.BATCH_SIZE) {
                batches.push(symbols.slice(i, i + CONFIG.BATCH_SIZE));
            }

            for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
                const batch = batches[batchIndex];
                const totalProcessed = batchIndex * CONFIG.BATCH_SIZE;
                
                for (let i = 0; i < batch.length; i++) {
                    const symbol = batch[i];
                    updateProgress(totalProcessed + i + 1, symbols.length, batchIndex + 1, batches.length);

                    try {
                        const data = await api.fetchVolumeData(symbol);
                        if (data?.volumeData?.data) {
                            state.volumeData.push({
                                symbol,
                                totalFlow: data.volumeData.data.totalInFlow || 0,
                                flows: data.volumeData.data.netCapitalInList || [],
                                marketData: data.marketData,
                                lastUpdated: new Date().toLocaleString()
                            });
                        }
                        
                        displayData();
                        
                        if (i < batch.length - 1) {
                            await utils.delay(CONFIG.REQUEST_DELAY);
                        }
                    } catch (error) {
                        console.error(`Error processing ${symbol}:`, error);
                    }
                }

                cache.save(state.volumeData);

                if (batchIndex < batches.length - 1) {
                    showMessage(`Waiting before processing batch ${batchIndex + 2}/${batches.length}...`, 'loading');
                    await utils.delay(CONFIG.BATCH_DELAY);
                }
            }
        }

        function setupAutoRefresh() {
            if (state.autoRefreshTimer) {
                clearInterval(state.autoRefreshTimer);
            }

            state.autoRefreshTimer = setInterval(() => {
                if (!state.isProcessing) {
                    console.log('Auto refreshing data...');
                    fetchAllData();
                }
            }, CONFIG.AUTO_REFRESH_INTERVAL);
        }

        async function fetchAllData() {
            if (state.isProcessing) {
                showMessage('Already processing data. Please wait...', 'error');
                return;
            }

            const fetchButton = document.getElementById('fetchButton');
            const loadingDiv = document.getElementById('loading');
            
            try {
                const cachedData = cache.get();
                if (cachedData) {
                    state.volumeData = cachedData;
                    displayData();
                    return;
                }

                state.isProcessing = true;
                fetchButton.disabled = true;
                loadingDiv.style.display = 'block';
                state.volumeData = [];

                if (state.symbols.length === 0) {
                    state.symbols = await api.getExchangeInfo();
                }

                await processBatch(state.symbols);
                cache.save(state.volumeData);
                updateStats();
            } catch (error) {
                showMessage('Error fetching data: ' + error.message, 'error');
            } finally {
                loadingDiv.style.display = 'none';
                fetchButton.disabled = false;
                state.isProcessing = false;
            }
        }

        function sortTable() {
            state.sortDirection = state.sortDirection === 'desc' ? 'asc' : 'desc';
            state.volumeData.sort((a, b) => {
                return state.sortDirection === 'desc' 
                    ? b.totalFlow - a.totalFlow 
                    : a.totalFlow - b.totalFlow;
            });
            displayData();
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            const cachedData = cache.get();
            if (cachedData) {
                state.volumeData = cachedData;
                displayData();
            } else {
                fetchAllData();
            }
            setupAutoRefresh();
        });

        // Event listeners
        document.getElementById('searchInput').addEventListener('input', displayData);
        window.clearCache = cache.clear;
    </script>
</body>
</html>
