<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <title>Binance Margin Debt Calculator 30d</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      padding: 20px;
    }
    .status {
      margin-top: 20px;
      padding: 10px;
      background: #f5f5f5;
      border-radius: 4px;
    }
    .data-table {
      width: 100%;
      margin-top: 20px;
      border-collapse: collapse;
    }
    .data-table th, .data-table td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
    }
    .data-table th {
      background-color: #f3f3f3;
      font-weight: bold;
    }
    #symbolList {
      margin-top: 20px;
      padding: 10px;
      background: #f8f9fa;
      border: 1px solid #ddd;
      display:none
    }
    .next-update {
      margin-top: 10px;
      color: #666;
    }
    .cache-status {
      margin-top: 10px;
      color: #28a745;
    }
    .refresh-timer {
      margin-top: 10px;
      color: #0056b3;
    }
  </style>
</head>
<body>
  <h2>Binance Margin Debt Calculator</h2>
  <div id="status" class="status">Starting...</div>
  <div id="nextUpdate" class="next-update"></div>
  <div id="refreshTimer" class="refresh-timer"></div>
  <div id="cacheStatus" class="cache-status"></div>
  
  <div id="symbolList"></div>

  <table class="data-table">
    <thead>
      <tr>
        <th>Symbol</th>
        <th>Current Time</th>
        <th>Current %</th>
        <th>Highest % (Time)</th>
      </tr>
    </thead>
    <tbody id="dataBody"></tbody>
  </table>

  <script>
    const BATCH_SIZE = 50;
    const BATCH_DELAY = 45000;
    const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours
    const REFRESH_INTERVAL = 8 * 60 * 60 * 1000; // 8 hours in milliseconds
    
    let cachedSymbols = null;
    let lastSymbolsUpdate = null;
    let cachedMarginData = new Map();
    let lastMarginUpdate = null;
    let nextUpdateTime = null;
    let nextRefreshTime = null;
    let isInitialLoad = true;

    window.onload = async function() {
      try {
        loadCacheFromStorage();
        await loadData();
        
        // Set up refresh margin debt every 15 minutes
        setInterval(async () => {
          document.getElementById('status').innerHTML = 'Refreshing margin debt data...';
          await refreshMarginDebt(false); // false means don't clear cache
          nextRefreshTime = new Date().getTime() + REFRESH_INTERVAL;
        }, REFRESH_INTERVAL);
        
        // Initial setup of next refresh time
        nextRefreshTime = new Date().getTime() + REFRESH_INTERVAL;
        
        // Update both countdowns
        setInterval(updateCountdowns, 1000);
        
      } catch (error) {
        document.getElementById('status').innerHTML = 'Error: ' + error.message;
        console.error(error);
      }
    }

    async function fetchSymbols() {
      try {
        const response = await fetch('https://api.binance.com/api/v3/exchangeInfo');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        
        let symbols = data.symbols
          .filter(s => s.quoteAsset === 'USDT' && s.status === 'TRADING')
          .map(s => s.baseAsset);
        
        // Ensure BTC is first
        symbols = ['BTC', ...symbols.filter(s => s !== 'BTC')];
        
        return symbols;
      } catch (error) {
        console.error('Error fetching symbols:', error);
        throw error;
      }
    }

    function loadCacheFromStorage() {
      try {
        // Load symbols cache
        const symbolsCache = localStorage.getItem('symbolsCache');
        if (symbolsCache) {
          const parsed = JSON.parse(symbolsCache);
          cachedSymbols = parsed.symbols;
          lastSymbolsUpdate = parsed.timestamp;
        }

        // Load margin data cache
        const marginCache = localStorage.getItem('marginCache');
        if (marginCache) {
          const parsed = JSON.parse(marginCache);
          cachedMarginData = new Map(Object.entries(parsed.data));
          lastMarginUpdate = parsed.timestamp;
          
          // Update cache status
          updateCacheStatus();
        }
      } catch (error) {
        console.error('Error loading cache:', error);
      }
    }

    function saveCacheToStorage() {
      try {
        // Save symbols cache
        if (cachedSymbols) {
          localStorage.setItem('symbolsCache', JSON.stringify({
            symbols: cachedSymbols,
            timestamp: lastSymbolsUpdate
          }));
        }

        // Save margin data cache
        if (cachedMarginData.size > 0) {
          localStorage.setItem('marginCache', JSON.stringify({
            data: Object.fromEntries(cachedMarginData),
            timestamp: lastMarginUpdate
          }));
        }
      } catch (error) {
        console.error('Error saving cache:', error);
      }
    }

    function updateCacheStatus() {
      const cacheStatus = document.getElementById('cacheStatus');
      if (lastMarginUpdate) {
        const cacheAge = Math.floor((new Date().getTime() - lastMarginUpdate) / (60 * 1000));
        const symbolCount = cachedMarginData.size;
        cacheStatus.innerHTML = `Cache: ${symbolCount} symbols, ${cacheAge} minutes old`;
      }
    }

    function updateCountdowns() {
      // Update cache countdown
      if (nextUpdateTime) {
        const now = new Date().getTime();
        const cacheTimeLeft = nextUpdateTime - now;
        
        if (cacheTimeLeft > 0) {
          const hours = Math.floor(cacheTimeLeft / (60 * 60 * 1000));
          const minutes = Math.floor((cacheTimeLeft % (60 * 60 * 1000)) / 60000);
          const seconds = Math.floor((cacheTimeLeft % 60000) / 1000);
          document.getElementById('nextUpdate').innerHTML = 
            `Cache expires in: ${hours}h ${minutes}m ${seconds}s`;
        } else {
          document.getElementById('nextUpdate').innerHTML = 
            'Cache expired - Update needed';
        }
      }

      // Update refresh countdown
      if (nextRefreshTime) {
        const now = new Date().getTime();
        const refreshTimeLeft = nextRefreshTime - now;
        
        if (refreshTimeLeft > 0) {
          const minutes = Math.floor(refreshTimeLeft / 60000);
          const seconds = Math.floor((refreshTimeLeft % 60000) / 1000);
          document.getElementById('refreshTimer').innerHTML = 
            `Next refresh in: ${minutes}m ${seconds}s`;
        }
      }
    }

    async function loadData() {
      const symbols = await getSymbolsWithCache();
      displaySymbols(symbols);
      
      const now = new Date().getTime();
      
      // Check if we have valid cached margin data
      if (cachedMarginData.size > 0 && lastMarginUpdate && 
          (now - lastMarginUpdate) < CACHE_DURATION) {
        // Use cached data
        document.getElementById('status').innerHTML = 'Loading from cache...';
        displayCachedData();
        nextUpdateTime = lastMarginUpdate + CACHE_DURATION;
      } else {
        // Fetch new data
        await refreshMarginDebt(true);
      }
    }

    function displayCachedData() {
      document.getElementById('dataBody').innerHTML = '';
      for (const data of cachedMarginData.values()) {
        addRowToTable(data);
      }
      updateCacheStatus();
    }

    async function getSymbolsWithCache() {
      const now = new Date().getTime();
      
      if (cachedSymbols && lastSymbolsUpdate && 
          (now - lastSymbolsUpdate) < CACHE_DURATION) {
        return cachedSymbols;
      }
      
      document.getElementById('status').innerHTML = 'Fetching symbols...';
      const symbols = await fetchSymbols();
      
      cachedSymbols = symbols;
      lastSymbolsUpdate = now;
      saveCacheToStorage();
      
      return symbols;
    }

    // Thêm hàm helper để format thời gian
function formatVietnameseTime(date) {
  return new Date(date).toLocaleString('vi-VN', { 
    timeZone: 'Asia/Ho_Chi_Minh',
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: false
  });
}

    async function refreshMarginDebt(clearCache = true) {
      if (!cachedSymbols) return;
      
      if (clearCache) {
        document.getElementById('dataBody').innerHTML = '';
        cachedMarginData.clear();
      }
      
      const batches = chunkArray(cachedSymbols, BATCH_SIZE);
      for(let i = 0; i < batches.length; i++) {
        document.getElementById('status').innerHTML = 
          `Processing batch ${i + 1}/${batches.length}...`;
        
        await processBatch(batches[i]);
        
        if (i < batches.length - 1) {
          document.getElementById('status').innerHTML = 
            'Waiting before next batch...';
          await new Promise(resolve => setTimeout(resolve, BATCH_DELAY));
        }
      }
      
      lastMarginUpdate = new Date().getTime();
      nextUpdateTime = lastMarginUpdate + CACHE_DURATION;
      saveCacheToStorage();
      updateCacheStatus();
      
      document.getElementById('status').innerHTML = 
        `Data updated successfully. Cached ${cachedMarginData.size} symbols.`;
    }

   // Sửa lại hàm processBatch để lưu timestamp dạng số
async function processBatch(symbols) {
  for(let symbol of symbols) {
    try {
      const marginUrl = `https://www.binance.com/bapi/margin/v1/public/margin/marketStats/marginDebt?asset=${symbol}&period=24&limit=30`;
      const marginResponse = await fetch(marginUrl);
      const marginData = await marginResponse.json();

      if (marginData.data && marginData.data.length > 0) {
        const sortedData = marginData.data.sort((a, b) => b.timestamp - a.timestamp);
        const latestData = sortedData[0];
        const highestData = sortedData.reduce((max, current) => 
          current.marginDebtGrowth > max.marginDebtGrowth ? current : max, sortedData[0]
        );

        const result = {
          symbol: symbol + '/USDT',
          currentTime: latestData.timestamp, // Lưu timestamp dạng số
          currentPercentage: (latestData.marginDebtGrowth * 100).toFixed(2),
          highestPercentage: (highestData.marginDebtGrowth * 100).toFixed(2),
          highestTime: highestData.timestamp // Lưu timestamp dạng số
        };

        // Update cache
        cachedMarginData.set(symbol, result);
        addRowToTable(result);

        await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .updateSymbolData(result);
        });
      }

      await new Promise(resolve => setTimeout(resolve, 1000));
      
    } catch (error) {
      console.error("Error processing " + symbol + ":", error);
    }
  }
}

    function displaySymbols(symbols) {
      const symbolList = document.getElementById('symbolList');
      symbolList.innerHTML = 'Found ' + symbols.length + ' symbols:<br>' +
        symbols.map((s, i) => (i + 1) + '. ' + s).join(', ');
    }

    function chunkArray(array, size) {
      const chunks = [];
      for (let i = 0; i < array.length; i += size) {
        chunks.push(array.slice(i, i + size));
      }
      return chunks;
    }

    // Sửa lại hàm addRowToTable
function addRowToTable(data) {
  const tbody = document.getElementById('dataBody');
  const row = document.createElement('tr');
  
  // Format thời gian theo giờ Việt Nam
  const currentTime = formatVietnameseTime(data.currentTime);
  const highestTime = formatVietnameseTime(data.highestTime);
  
  row.innerHTML = 
    `<td>${data.symbol}</td>
     <td>${currentTime}</td>
     <td>${data.currentPercentage}%</td>
     <td>${data.highestPercentage}% (${highestTime})</td>`;
  
  tbody.appendChild(row);
  row.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}
  </script>
</body>
</html>
